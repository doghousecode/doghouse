<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Doghouse</title>
  <style>
    :root {
      color-scheme: light dark;

      --bg: #f6f6f7;
      --card: #ffffff;
      --text: #111111;
      --muted: #666666;
      --border: #e8e8ea;

      --pill-bg: #ffffff;
      --pill-text: #111111;
      --pill-active-bg: #111111;
      --pill-active-text: #ffffff;

      --btn-bg: #111111;
      --btn-text: #ffffff;

      --field-bg: #ffffff;
      --field-text: #111111;

      --kpi-bg: #fafafa;
      --danger: #b91c1c;

      /* Chart + badges */
      --active-line: #3b82f6;      /* mid-blue */
      --inactive-line: rgba(0,0,0,0.22);
      --event-flea: #f59e0b;       /* amber */
      --event-vax: #22c55e;        /* green */
      --badge-bg: rgba(0,0,0,0.06);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b0b0c;
        --card: #141416;
        --text: #f2f2f3;
        --muted: #a1a1a7;
        --border: #2a2a2e;

        --pill-bg: #1b1b1e;
        --pill-text: #f2f2f3;
        --pill-active-bg: #f2f2f3;
        --pill-active-text: #111111;

        --btn-bg: #f2f2f3;
        --btn-text: #111111;

        --field-bg: #1b1b1e;
        --field-text: #f2f2f3;

        --kpi-bg: #1a1a1d;
        --danger: #ff6b6b;

        --inactive-line: rgba(255,255,255,0.22);
        --badge-bg: rgba(255,255,255,0.08);
      }
    }

    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, system-ui, Arial, sans-serif;
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }

    header {
      padding: 16px 14px;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    h1 { margin: 0; font-size: 18px; }
    .sub { margin: 6px 0 0; color: var(--muted); font-size: 13px; }

    main { padding: 14px; max-width: 900px; margin: 0 auto; }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 1px 0 rgba(0,0,0,.03);
      overflow: hidden;
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .row > * { flex: 1; min-width: 0; }

    .pill {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      text-align: center;
      cursor: pointer;
      background: var(--pill-bg);
      color: var(--pill-text);
      user-select: none;
    }

    .pillToggle {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 14px 12px;
      text-align: center;
      min-height: 150px;
      box-shadow: 0 1px 0 rgba(0,0,0,.03);
    }

    .pillToggle .avatar {
      width: 120px;
      height: 150px;
      border-radius: 14px;
      object-fit: cover;
      background: transparent;
      border: none !important;
      box-shadow: none !important;
    }

    .pillToggle:active { transform: scale(0.98); }

    .pillToggle span {
      font-weight: 600;
      font-size: 14px;
    }

    .pill.active {
      background: var(--pill-active-bg);
      color: var(--pill-active-text);
      border-color: var(--pill-active-bg);
    }

    @media (prefers-color-scheme: dark) {
      .pill.active .avatar { box-shadow: 0 0 0 4px rgba(0,0,0,0.35); }
    }

    label { display: block; margin: 12px 0 6px; font-size: 12px; color: var(--muted); }

    input, select, textarea, button { width: 100%; font: inherit; }
    input, select, textarea {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--field-bg);
      color: var(--field-text);
      max-width: 100%;
    }

    input[type="date"] { width: 100%; min-width: 0; display: block; }

    @supports (-webkit-touch-callout: none) {
      input[type="date"] {
        width: 100%;
        max-width: 100%;
        min-width: 0;
        box-sizing: border-box;
        display: block;
        -webkit-appearance: none;
        appearance: none;
      }
    }

    textarea { min-height: 70px; resize: vertical; }

    button.primary {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--btn-bg);
      background: var(--btn-bg);
      color: var(--btn-text);
      cursor: pointer;
    }

    button.secondary {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      cursor: pointer;
    }

    .muted { color: var(--muted); font-size: 13px; }
    .error { color: var(--danger); }

    .kpi {
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--kpi-bg);
    }

    .kpiGrid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }

    .kpiLine b { color: var(--text); }
    .kpiSmall { font-size: 12px; }

    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { padding: 10px 8px; border-bottom: 1px solid var(--border); font-size: 13px; vertical-align: top; }
    th { text-align: left; color: var(--muted); font-weight: 600; }

    .btnrow { display: flex; gap: 8px; justify-content: flex-end; flex-wrap: wrap; }
    .smallbtn {
      width: auto;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      cursor: pointer;
    }

    .actionsRow { margin-top: 12px; gap: 10px; }

    @media (max-width: 420px) {
      th:nth-child(3), td:nth-child(3) { display: none; }
    }

    /* FINAL authority for dog toggle colours */
    .pill.pillToggle {
      background: var(--pill-bg) !important;
      color: var(--pill-text) !important;
      border-color: var(--border) !important;
    }
    .pill.pillToggle.active {
      background: var(--pill-active-bg) !important;
      color: var(--pill-active-text) !important;
      border-color: var(--pill-active-bg) !important;
    }

    /* Entry type segmented control */
    .segRow { margin-top: 12px; }
    .seg {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .segBtn {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 10px;
      background: var(--card);
      color: var(--text);
      cursor: pointer;
      user-select: none;
      text-align: center;
      font-weight: 600;
      font-size: 13px;
    }
    .segBtn[aria-pressed="true"] {
      background: var(--pill-active-bg);
      color: var(--pill-active-text);
      border-color: var(--pill-active-bg);
    }
    .hintRow { margin-top: 6px; font-size: 12px; color: var(--muted); }

    /* Row badges */
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--badge-bg);
      border: 1px solid var(--border);
      font-size: 12px;
      line-height: 18px;
      white-space: nowrap;
    }
    .badgeWeight { }
    .badgeFlea { border-color: color-mix(in srgb, var(--event-flea) 40%, var(--border)); }
    .badgeVax  { border-color: color-mix(in srgb, var(--event-vax) 40%, var(--border)); }

    .rowFlea td { background: color-mix(in srgb, var(--event-flea) 12%, transparent); }
    .rowVax  td { background: color-mix(in srgb, var(--event-vax)  12%, transparent); }

    #trend {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 85%, var(--bg));
    }

    .legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .legendSwatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
      vertical-align: middle;
      margin-right: 6px;
      border: 1px solid var(--border);
    }
    .legendX {
      font-weight: 900;
      display: inline-block;
      width: 12px;
      text-align: center;
      margin-right: 6px;
    }
  </style>
</head>

<body>
<header>
  <h1>The Doghouse</h1>
  <p class="sub">He ain't heavy...he's my brother</p>
</header>

<main>
  <div class="card">
    <div class="row" style="gap:8px;">
      <div id="pill-watson" class="pill pillToggle active" role="button" tabindex="0" aria-pressed="true">
        <img class="avatar" src="assets/watson.png" alt="Dr Watson" />
        <span>Dr Watson</span>
      </div>

      <div id="pill-eddie" class="pill pillToggle" role="button" tabindex="0" aria-pressed="false">
        <img class="avatar" src="assets/eddie.png" alt="Eddie Spaghetti" />
        <span>Eddie Spaghetti</span>
      </div>
    </div>

    <div class="kpi muted">
      <div class="kpiGrid">
        <div class="kpiLine">Latest weigh-in: <b id="latest">—</b></div>
        <div class="kpiLine">Change: <b id="delta">—</b> <span class="muted">since previous weigh-in</span></div>
        <div class="kpiLine kpiSmall">Flea &amp; worm: <b id="fleaDue">—</b></div>
        <div class="kpiLine kpiSmall">Health check &amp; vax: <b id="vaxDue">—</b></div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <canvas id="trend" height="180" style="width:100%; height:180px; display:block;"></canvas>
      <div class="legend">
        <span><span class="legendSwatch" id="swActive"></span>Active dog (mid-blue)</span>
        <span><span class="legendSwatch" id="swInactive"></span>Other dog</span>
        <span><span class="legendX" style="color:var(--event-flea);">×</span>Flea/Worm</span>
        <span><span class="legendX" style="color:var(--event-vax);">×</span>Vax</span>
      </div>
      <div class="muted" id="trendLabel" style="margin-top:6px;">—</div>
    </div>

    <label>Date</label>
    <input id="date" type="date" />

    <div class="segRow">
      <div class="seg" role="group" aria-label="Entry type">
        <button id="type-weight" class="segBtn" type="button" aria-pressed="true">Weigh-in</button>
        <button id="type-flea" class="segBtn" type="button" aria-pressed="false">Flea &amp; worm</button>
        <button id="type-vax" class="segBtn" type="button" aria-pressed="false">Health check &amp; vax</button>
      </div>
      <div class="hintRow" id="typeHint">Record a weigh-in (stored in canonical kg, lb supported).</div>
    </div>

    <div id="weightBlock">
      <label>Weight entry</label>
      <div class="row">
        <input id="weight" type="number" inputmode="decimal" step="0.1" placeholder="e.g., 18.4" />
        <select id="unit">
          <option value="kg">kg</option>
          <option value="lb">lb</option>
        </select>
      </div>
      <div class="muted" id="converted">—</div>
    </div>

    <label id="notesLabel">Notes (optional)</label>
    <textarea id="notes" placeholder="e.g., annual checkup, on new food…"></textarea>

    <div class="row" style="gap:10px;">
      <button id="save" class="primary" type="button">Save entry</button>
      <button id="cancelEdit" class="secondary" type="button" style="display:none;">Cancel edit</button>
    </div>

    <p class="muted" id="msg" style="margin: 10px 0 0;"></p>

    <table>
      <thead>
        <tr>
          <th>Date</th>
          <th>Entry</th>
          <th>Notes</th>
          <th style="width:160px;"></th>
        </tr>
      </thead>
      <tbody id="rows">
        <tr><td colspan="4" class="muted">No entries yet.</td></tr>
      </tbody>
    </table>

    <div class="row actionsRow">
      <button id="exportJson" class="smallbtn" type="button">Export JSON</button>
      <button id="exportCsv" class="smallbtn" type="button">Export CSV</button>
      <button id="importJson" class="smallbtn" type="button">Import JSON</button>
      <button id="clearDog" class="smallbtn" type="button">Clear dog data</button>
    </div>
  </div>
</main>

<script>
  let trendWidthPx = null;
  const TREND_HEIGHT = 180;

  const DOGS = { watson: "Dr Watson", eddie: "Eddie Spaghetti" };
  const DOG_KEYS = ["watson","eddie"];

  const KG_PER_LB = 1 / 2.2046226218;
  const LB_PER_KG = 2.2046226218;
  function kgToLb(kg) { return kg * LB_PER_KG; }
  function lbToKg(lb) { return lb * KG_PER_LB; }

  const els = {
    pillWatson: document.getElementById("pill-watson"),
    pillEddie: document.getElementById("pill-eddie"),
    date: document.getElementById("date"),
    weight: document.getElementById("weight"),
    unit: document.getElementById("unit"),
    notes: document.getElementById("notes"),
    notesLabel: document.getElementById("notesLabel"),
    converted: document.getElementById("converted"),
    save: document.getElementById("save"),
    cancelEdit: document.getElementById("cancelEdit"),
    rows: document.getElementById("rows"),
    latest: document.getElementById("latest"),
    delta: document.getElementById("delta"),
    fleaDue: document.getElementById("fleaDue"),
    vaxDue: document.getElementById("vaxDue"),
    msg: document.getElementById("msg"),
    exportJson: document.getElementById("exportJson"),
    exportCsv: document.getElementById("exportCsv"),
    importJson: document.getElementById("importJson"),
    clearDog: document.getElementById("clearDog"),
    trendCanvas: document.getElementById("trend"),
    trendLabel: document.getElementById("trendLabel"),
    swActive: document.getElementById("swActive"),
    swInactive: document.getElementById("swInactive"),

    typeWeight: document.getElementById("type-weight"),
    typeFlea: document.getElementById("type-flea"),
    typeVax: document.getElementById("type-vax"),
    typeHint: document.getElementById("typeHint"),
    weightBlock: document.getElementById("weightBlock"),
  };

  let activeDog = "watson";
  let editingId = null;
  let entryType = "weight"; // "weight" | "flea" | "vax"

  function setMsg(text, isError=false) {
    els.msg.textContent = text || "";
    els.msg.classList.toggle("error", !!isError);
  }

  // Safe error reporter (won't crash if something is off)
  window.addEventListener("error", (e) => {
    try {
      const msg = e?.message || "Unknown error";
      setMsg(`JS error: ${msg}`, true);
    } catch {}
  });

  function todayISO() {
    const d = new Date();
    const off = d.getTimezoneOffset();
    const local = new Date(d.getTime() - off * 60000);
    return local.toISOString().slice(0, 10);
  }

  function keyForDog(dogKey) { return `dogweights:v4:${dogKey}`; }

  function normalizeEntry(e) {
    // v4 native:
    if (e && typeof e === "object" && e.type) return e;

    // v3/v2 legacy weight entry {id,date,kg,notes}
    if (e && typeof e === "object" && typeof e.kg === "number" && e.date) {
      return { id: e.id || String(Date.now()), date: e.date, type: "weight", kg: e.kg, notes: e.notes || "" };
    }

    // v1 legacy {weight,unit}
    if (e && typeof e === "object" && typeof e.weight === "number" && typeof e.unit === "string" && e.date) {
      const kg = (e.unit === "kg") ? e.weight : lbToKg(e.weight);
      return { id: e.id || String(Date.now()), date: e.date, type: "weight", kg, notes: e.notes || "" };
    }

    return null;
  }

  function loadEntries(dogKey) {
    try {
      const raw = JSON.parse(localStorage.getItem(keyForDog(dogKey)) || "[]");
      const arr = Array.isArray(raw) ? raw : [];
      return arr.map(normalizeEntry).filter(Boolean);
    } catch {
      return [];
    }
  }

  function saveEntries(dogKey, entries) {
    localStorage.setItem(keyForDog(dogKey), JSON.stringify(entries));
  }

  function esc(s) {
    return (s || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;");
  }

  function sortedEntriesDesc(entries) {
    return [...entries].sort((a,b) => (b.date > a.date ? 1 : (b.date < a.date ? -1 : 0)));
  }

  function weightsOnly(entries) {
    return entries.filter(e => e.type === "weight" && typeof e.kg === "number");
  }

  function eventsOnly(entries) {
    return entries.filter(e => e.type === "flea" || e.type === "vax");
  }

  function canonicalKgFromInput() {
    const w = Number(els.weight.value);
    if (!Number.isFinite(w) || w <= 0) return null;
    return (els.unit.value === "kg") ? w : lbToKg(w);
  }

  function updateConverted() {
    if (entryType !== "weight") { els.converted.textContent = "—"; return; }

    const v = Number(els.weight.value);
    if (!Number.isFinite(v) || v <= 0) { els.converted.textContent = "—"; return; }
    if (els.unit.value === "kg") {
      els.converted.textContent = `${kgToLb(v).toFixed(1)} lb (stored as ${v.toFixed(1)} kg)`;
    } else {
      const kg = lbToKg(v);
      els.converted.textContent = `${kg.toFixed(1)} kg (stored as ${kg.toFixed(1)} kg)`;
    }
  }

  function computeLatestAndDelta(entries) {
    const w = sortedEntriesDesc(weightsOnly(entries));
    if (w.length === 0) return { latestText: "—", deltaText: "—" };

    const latest = w[0];
    const latestText = `${latest.kg.toFixed(1)} kg (${kgToLb(latest.kg).toFixed(1)} lb) on ${latest.date}`;

    if (w.length < 2) return { latestText, deltaText: "—" };

    const prev = w[1];
    const deltaKg = latest.kg - prev.kg;
    const sign = deltaKg > 0 ? "+" : (deltaKg < 0 ? "−" : "");
    const deltaText = `${sign}${Math.abs(deltaKg).toFixed(1)} kg (${sign}${Math.abs(kgToLb(deltaKg)).toFixed(1)} lb)`;
    return { latestText, deltaText };
  }

  function lastOfType(entries, type) {
    const s = sortedEntriesDesc(entries.filter(e => e.type === type));
    return s[0] || null;
  }

  function addDaysISO(iso, days) {
    const [y,m,d] = iso.split("-").map(Number);
    const dt = new Date(y, m-1, d, 12, 0, 0);
    dt.setDate(dt.getDate() + days);
    const off = dt.getTimezoneOffset();
    const local = new Date(dt.getTime() - off * 60000);
    return local.toISOString().slice(0, 10);
  }

  function addYearsISO(iso, years) {
    const [y,m,d] = iso.split("-").map(Number);
    const dt = new Date(y, m-1, d, 12, 0, 0);
    dt.setFullYear(dt.getFullYear() + years);
    const off = dt.getTimezoneOffset();
    const local = new Date(dt.getTime() - off * 60000);
    return local.toISOString().slice(0, 10);
  }

  function formatDueLine(lastIso, nextIso, label) {
    if (!lastIso) return `No ${label} recorded yet.`;
    return `Last ${label}: ${lastIso} • Next due: ${nextIso}`;
  }

  function setEntryType(nextType) {
    entryType = nextType;

    els.typeWeight.setAttribute("aria-pressed", String(entryType === "weight"));
    els.typeFlea.setAttribute("aria-pressed", String(entryType === "flea"));
    els.typeVax.setAttribute("aria-pressed", String(entryType === "vax"));

    // UI toggles
    if (entryType === "weight") {
      els.weightBlock.style.display = "";
      els.notesLabel.textContent = "Notes (optional)";
      els.notes.placeholder = "e.g., annual checkup, on new food…";
      els.typeHint.textContent = "Record a weigh-in (stored in canonical kg, lb supported).";
      els.save.textContent = editingId ? "Save changes" : "Save entry";
    } else if (entryType === "flea") {
      els.weightBlock.style.display = "none";
      els.notesLabel.textContent = "Notes (optional)";
      els.notes.placeholder = "e.g., brand, dose, ‘ordered more’…";
      els.typeHint.textContent = "Record flea & worm meds (monthly reminder).";
      els.save.textContent = editingId ? "Save changes" : "Save entry";
    } else {
      els.weightBlock.style.display = "none";
      els.notesLabel.textContent = "Notes (optional)";
      els.notes.placeholder = "e.g., clinic, batch number, due date…";
      els.typeHint.textContent = "Record annual health check & vaccination.";
      els.save.textContent = editingId ? "Save changes" : "Save entry";
    }

    updateConverted();
  }

  function setActiveDog(dogKey) {
    activeDog = dogKey;

    els.pillWatson.classList.toggle("active", dogKey === "watson");
    els.pillEddie.classList.toggle("active", dogKey === "eddie");

    els.pillWatson.setAttribute("aria-pressed", dogKey === "watson");
    els.pillEddie.setAttribute("aria-pressed", dogKey === "eddie");

    cancelEdit();
    setMsg("");
    render();
  }

  function startEdit(id) {
    const entries = loadEntries(activeDog);
    const e = entries.find(x => x.id === id);
    if (!e) return;

    editingId = id;
    els.date.value = e.date;

    // Match type selector to entry being edited
    setEntryType(e.type);

    if (e.type === "weight") {
      els.weight.value = Number(e.kg).toFixed(1);
      els.unit.value = "kg";
      updateConverted();
    } else {
      els.weight.value = "";
      els.unit.value = "kg";
      updateConverted();
    }

    els.notes.value = e.notes || "";

    els.save.textContent = "Save changes";
    els.cancelEdit.style.display = "";
    setMsg(`Editing ${e.type} entry for ${DOGS[activeDog]}.`);
  }

  function cancelEdit() {
    editingId = null;
    els.cancelEdit.style.display = "none";
    els.save.textContent = "Save entry";
    els.date.value = todayISO();
    els.weight.value = "";
    els.unit.value = "kg";
    els.notes.value = "";
    setEntryType("weight");
    updateConverted();
  }

  function deleteEntry(id) {
    const next = loadEntries(activeDog).filter(x => x.id !== id);
    saveEntries(activeDog, next);
    if (editingId === id) cancelEdit();
    render();
  }

  function initTrendCanvas() {
    if (!els.trendCanvas || trendWidthPx !== null) return;

    const rect = els.trendCanvas.parentElement.getBoundingClientRect();
    trendWidthPx = Math.floor(rect.width);

    const dpr = window.devicePixelRatio || 1;
    els.trendCanvas.style.width = trendWidthPx + "px";
    els.trendCanvas.style.height = TREND_HEIGHT + "px";
    els.trendCanvas.width  = Math.floor(trendWidthPx * dpr);
    els.trendCanvas.height = Math.floor(TREND_HEIGHT * dpr);

    const ctx = els.trendCanvas.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function toTime(iso) { return new Date(iso + "T12:00:00").getTime(); }

  function findNearestWeightY(dataWeightsSortedAsc, t) {
    // Returns kg from nearest weight point by date.
    if (!dataWeightsSortedAsc.length) return null;
    let best = dataWeightsSortedAsc[0];
    let bestDist = Math.abs(best.t - t);
    for (let i = 1; i < dataWeightsSortedAsc.length; i++) {
      const d = Math.abs(dataWeightsSortedAsc[i].t - t);
      if (d < bestDist) { best = dataWeightsSortedAsc[i]; bestDist = d; }
    }
    return best.kg;
  }

  function drawX(ctx, x, y, size, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x - size, y - size);
    ctx.lineTo(x + size, y + size);
    ctx.moveTo(x - size, y + size);
    ctx.lineTo(x + size, y - size);
    ctx.stroke();
  }

  function drawTrend(allByDog) {
    if (!els.trendCanvas) return;
    initTrendCanvas();

    const ctx = els.trendCanvas.getContext("2d");
    ctx.clearRect(0, 0, trendWidthPx, TREND_HEIGHT);

    const root = getComputedStyle(document.documentElement);
    const text = root.getPropertyValue("--text").trim() || "#111";
    const muted = root.getPropertyValue("--muted").trim() || "#666";
    const border = root.getPropertyValue("--border").trim() || "#ddd";
    const activeLine = root.getPropertyValue("--active-line").trim() || "#3b82f6";
    const inactiveLine = root.getPropertyValue("--inactive-line").trim() || "rgba(0,0,0,0.22)";
    const fleaC = root.getPropertyValue("--event-flea").trim() || "#f59e0b";
    const vaxC  = root.getPropertyValue("--event-vax").trim()  || "#22c55e";

    // Collect weight points for both dogs
    const weightsByDog = {};
    let allWeights = [];
    for (const dog of DOG_KEYS) {
      const w = weightsOnly(allByDog[dog] || []);
      const pts = w
        .filter(e => e.date && typeof e.kg === "number")
        .map(e => ({ t: toTime(e.date), kg: e.kg, date: e.date }))
        .sort((a,b) => a.t - b.t);
      weightsByDog[dog] = pts;
      allWeights = allWeights.concat(pts.map(p => ({...p, dog})));
    }

    // Need at least 2 total points to draw meaningful axes
    if (allWeights.length < 2) {
      els.trendLabel.textContent = allWeights.length === 1 ? "Add one more weigh-in (either dog) to see trends." : "No trend yet.";
      return;
    }

    // plot padding (left bigger for kg labels, bottom smaller for years)
    const padL = 38;
    const padR = 14;
    const padT = 14;
    const padB = 22;

    const left = padL;
    const right = trendWidthPx - padR;
    const top = padT;
    const bottom = TREND_HEIGHT - padB;

    // X domain
    const tMin = Math.min(...allWeights.map(p => p.t));
    const tMax = Math.max(...allWeights.map(p => p.t));

    // Y domain (include forced context ticks 25 and 30 always)
    let yMin = Math.min(...allWeights.map(p => p.kg));
    let yMax = Math.max(...allWeights.map(p => p.kg));
    const forcedTicks = [25, 30];
    for (const t of forcedTicks) {
      yMin = Math.min(yMin, t);
      yMax = Math.max(yMax, t);
    }

    // pad y range a bit
    const yPad = Math.max(0.2, (yMax - yMin) * 0.12);
    yMin -= yPad;
    yMax += yPad;

    const xFor = t => left + (t - tMin) / (tMax - tMin) * (right - left);
    const yFor = kg => bottom - (kg - yMin) / (yMax - yMin) * (bottom - top);

    // choose tick step (avoid clutter)
    const range = (yMax - yMin);
    let step = 5;
    const approxTicks = Math.floor(range / step);
    if (approxTicks > 9) step = 10;

    // grid + Y labels
    ctx.fillStyle = muted;
    ctx.font = "11px system-ui";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";

    const startKg = Math.ceil(yMin / step) * step;
    const endKg   = Math.floor(yMax / step) * step;

    ctx.strokeStyle = "rgba(0,0,0,0.06)";
    ctx.lineWidth = 1;

    for (let kg = startKg; kg <= endKg; kg += step) {
      const y = yFor(kg);
      ctx.fillText(`${kg}kg`, left - 6, y);
      ctx.beginPath();
      ctx.moveTo(left, y);
      ctx.lineTo(right, y);
      ctx.stroke();
    }

    // X labels (whole years)
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillStyle = muted;

    const startYear = new Date(tMin).getFullYear();
    const endYear = new Date(tMax).getFullYear();

    for (let year = startYear; year <= endYear; year++) {
      const tt = new Date(year, 0, 1, 12).getTime();
      if (tt < tMin || tt > tMax) continue;

      const x = xFor(tt);
      ctx.fillText(String(year), x, bottom + 6);

      ctx.strokeStyle = "rgba(0,0,0,0.06)";
      ctx.beginPath();
      ctx.moveTo(x, top);
      ctx.lineTo(x, bottom);
      ctx.stroke();
    }

    // Draw lines: active dog in blue, other dog in inactive gray
    function drawLineForDog(dogKey) {
      const pts = weightsByDog[dogKey] || [];
      if (pts.length < 2) return;

      const isActive = dogKey === activeDog;
      ctx.strokeStyle = isActive ? activeLine : inactiveLine;
      ctx.lineWidth = isActive ? 2.6 : 2;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      ctx.beginPath();
      pts.forEach((p, i) => {
        const x = xFor(p.t);
        const y = yFor(p.kg);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Points
      ctx.fillStyle = isActive ? activeLine : inactiveLine;
      pts.forEach(p => {
        const x = xFor(p.t);
        const y = yFor(p.kg);
        ctx.beginPath();
        ctx.arc(x, y, isActive ? 2.8 : 2.2, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Draw inactive first, then active on top
    const otherDog = activeDog === "watson" ? "eddie" : "watson";
    drawLineForDog(otherDog);
    drawLineForDog(activeDog);

    // Draw event X markers for both dogs
    function drawEventsForDog(dogKey) {
      const events = eventsOnly(allByDog[dogKey] || [])
        .filter(e => e.date)
        .map(e => ({ t: toTime(e.date), type: e.type, date: e.date }));

      if (!events.length) return;

      const pts = (weightsByDog[dogKey] || []);
      for (const ev of events) {
        const kgAt = findNearestWeightY(pts, ev.t);
        if (kgAt === null) continue; // no weight line to anchor to
        const x = xFor(ev.t);
        const y = yFor(kgAt);

        const color = (ev.type === "flea") ? fleaC : vaxC;
        const size = (dogKey === activeDog) ? 5 : 4;
        drawX(ctx, x, y, size, color);
      }
    }

    drawEventsForDog(otherDog);
    drawEventsForDog(activeDog);

    // Legend swatches
    els.swActive.style.background = activeLine;
    els.swInactive.style.background = inactiveLine;

    // Summary label
    const activePts = weightsByDog[activeDog] || [];
    const otherPts = weightsByDog[otherDog] || [];
    const aTxt = activePts.length ? `${DOGS[activeDog]}: ${activePts[activePts.length-1].kg.toFixed(1)}kg` : `${DOGS[activeDog]}: —`;
    const oTxt = otherPts.length ? `${DOGS[otherDog]}: ${otherPts[otherPts.length-1].kg.toFixed(1)}kg` : `${DOGS[otherDog]}: —`;
    els.trendLabel.textContent = `${aTxt} • ${oTxt}`;
  }

  window.addEventListener("resize", () => {
    trendWidthPx = null;
    initTrendCanvas();
    if (window.__lastAllByDog) drawTrend(window.__lastAllByDog);
  });

  function typeLabel(t) {
    if (t === "weight") return "Weigh-in";
    if (t === "flea") return "Flea/Worm";
    return "Vax";
  }

  function typeBadgeClass(t) {
    if (t === "flea") return "badge badgeFlea";
    if (t === "vax") return "badge badgeVax";
    return "badge badgeWeight";
  }

  function render() {
    const activeEntries = loadEntries(activeDog);
    const { latestText, deltaText } = computeLatestAndDelta(activeEntries);
    els.latest.textContent = latestText;
    els.delta.textContent = deltaText;

    // Reminders for active dog
    const fleaLast = lastOfType(activeEntries, "flea");
    const vaxLast = lastOfType(activeEntries, "vax");

    const fleaNext = fleaLast ? addDaysISO(fleaLast.date, 30) : null;
    const vaxNext  = vaxLast ? addYearsISO(vaxLast.date, 1) : null;

    els.fleaDue.textContent = fleaLast ? formatDueLine(fleaLast.date, fleaNext, "flea/worm") : "No flea/worm recorded yet.";
    els.vaxDue.textContent  = vaxLast ? formatDueLine(vaxLast.date, vaxNext, "vax") : "No vax recorded yet.";

    // Table: show ALL entry types for active dog
    const s = sortedEntriesDesc(activeEntries);
    if (s.length === 0) {
      els.rows.innerHTML = `<tr><td colspan="4" class="muted">No entries yet.</td></tr>`;
    } else {
      els.rows.innerHTML = s.map(e => {
        const badge = `<span class="${typeBadgeClass(e.type)}">${typeLabel(e.type)}</span>`;
        const entryText =
          e.type === "weight"
            ? `${badge}<div style="margin-top:6px;"><b>${Number(e.kg).toFixed(1)} kg</b><br><span class="muted">${kgToLb(Number(e.kg)).toFixed(1)} lb</span></div>`
            : `${badge}`;

        const trClass = e.type === "flea" ? "rowFlea" : (e.type === "vax" ? "rowVax" : "");
        return `
          <tr class="${trClass}">
            <td>${e.date}</td>
            <td>${entryText}</td>
            <td>${esc(e.notes)}</td>
            <td>
              <div class="btnrow">
                <button class="smallbtn" data-edit="${e.id}">Edit</button>
                <button class="smallbtn" data-del="${e.id}">Delete</button>
              </div>
            </td>
          </tr>
        `;
      }).join("");

      els.rows.querySelectorAll("button[data-edit]").forEach(btn => {
        btn.addEventListener("click", () => startEdit(btn.getAttribute("data-edit")));
      });
      els.rows.querySelectorAll("button[data-del]").forEach(btn => {
        btn.addEventListener("click", () => deleteEntry(btn.getAttribute("data-del")));
      });
    }

    // Chart uses both dogs data
    const allByDog = {
      watson: loadEntries("watson"),
      eddie: loadEntries("eddie"),
    };
    window.__lastAllByDog = allByDog;
    drawTrend(allByDog);
  }

  function downloadText(filename, text, mime) {
    const blob = new Blob([text], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function toCSVRow(fields) {
    return fields.map(v => {
      const s = String(v ?? "");
      const needs = /[",\n]/.test(s);
      return needs ? `"${s.replaceAll('"', '""')}"` : s;
    }).join(",");
  }

  // Wire UI
  els.pillWatson.addEventListener("click", () => setActiveDog("watson"));
  els.pillEddie.addEventListener("click", () => setActiveDog("eddie"));
  els.weight.addEventListener("input", updateConverted);
  els.unit.addEventListener("change", updateConverted);
  els.cancelEdit.addEventListener("click", () => { setMsg(""); cancelEdit(); render(); });

  els.typeWeight.addEventListener("click", () => { if (!editingId) setEntryType("weight"); });
  els.typeFlea.addEventListener("click", () => { if (!editingId) setEntryType("flea"); });
  els.typeVax.addEventListener("click", () => { if (!editingId) setEntryType("vax"); });

  els.save.addEventListener("click", () => {
    const date = els.date.value || todayISO();
    const notes = els.notes.value.trim();

    const entries = loadEntries(activeDog);

    // Editing flow
    if (editingId) {
      const idx = entries.findIndex(x => x.id === editingId);
      if (idx < 0) { setMsg("Couldn’t find entry to edit (it may have been deleted).", true); cancelEdit(); render(); return; }

      const original = entries[idx];
      const nextType = entryType;

      if (nextType === "weight") {
        const kg = canonicalKgFromInput();
        if (kg === null) { setMsg("Enter a valid weight first.", true); return; }
        entries[idx] = { ...original, date, type: "weight", kg, notes };
      } else {
        entries[idx] = { ...original, date, type: nextType, notes, kg: undefined };
        delete entries[idx].kg;
      }

      saveEntries(activeDog, entries);
      setMsg(`Updated entry for ${DOGS[activeDog]}.`);
      cancelEdit();
      render();
      return;
    }

    // New entry flow
    if (entryType === "weight") {
      const kg = canonicalKgFromInput();
      if (kg === null) { setMsg("Enter a valid weight first.", true); return; }

      // sanity check vs last weigh-in
      const latestW = sortedEntriesDesc(weightsOnly(entries))[0];
      if (latestW) {
        const pct = Math.abs((kg - latestW.kg) / latestW.kg) * 100;
        if (pct >= 20) setMsg(`Heads-up: that’s a ${pct.toFixed(0)}% change vs last weigh-in. Double-check? (Saving anyway)`);
        else setMsg("");
      } else {
        setMsg("");
      }

      const entry = {
        id: (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now())),
        date,
        type: "weight",
        kg,
        notes
      };
      entries.push(entry);
      saveEntries(activeDog, entries);

      els.weight.value = "";
      els.notes.value = "";
      els.unit.value = "kg";
      updateConverted();

      setMsg(`Saved weigh-in for ${DOGS[activeDog]}.`);
      render();
      return;
    }

    // flea / vax
    const entry = {
      id: (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now())),
      date,
      type: entryType, // "flea" or "vax"
      notes
    };
    entries.push(entry);
    saveEntries(activeDog, entries);

    els.notes.value = "";
    setMsg(`Saved ${entryType === "flea" ? "flea/worm" : "vax"} for ${DOGS[activeDog]}.`);
    render();
  });

  els.exportJson.addEventListener("click", () => {
    const payload = {
      version: 4,
      exportedAt: new Date().toISOString(),
      data: {
        watson: loadEntries("watson"),
        eddie: loadEntries("eddie"),
      }
    };
    downloadText("doghouse-backup.json", JSON.stringify(payload, null, 2), "application/json");
    setMsg("Exported JSON backup.");
  });

  els.exportCsv.addEventListener("click", () => {
    const all = [];
    for (const dog of DOG_KEYS) {
      const entries = loadEntries(dog).map(e => ({ dog: DOGS[dog], ...e }));
      all.push(...entries);
    }
    all.sort((a,b) => (a.date > b.date ? 1 : (a.date < b.date ? -1 : 0)));

    const header = toCSVRow(["dog", "date", "type", "weight_kg", "weight_lb", "notes"]);
    const rows = all.map(e => toCSVRow([
      e.dog,
      e.date,
      e.type,
      (e.type === "weight" && typeof e.kg === "number") ? Number(e.kg).toFixed(1) : "",
      (e.type === "weight" && typeof e.kg === "number") ? kgToLb(Number(e.kg)).toFixed(1) : "",
      e.notes || ""
    ]));

    downloadText("doghouse.csv", [header, ...rows].join("\n"), "text/csv");
    setMsg("Exported CSV.");
  });

  els.importJson.addEventListener("click", async () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "application/json";

    input.onchange = async () => {
      const file = input.files?.[0];
      if (!file) return;

      try {
        const text = await file.text();
        const parsed = JSON.parse(text);

        // v4 format
        if (parsed?.data?.watson && parsed?.data?.eddie) {
          const watson = (Array.isArray(parsed.data.watson) ? parsed.data.watson : []).map(normalizeEntry).filter(Boolean);
          const eddie  = (Array.isArray(parsed.data.eddie) ? parsed.data.eddie : []).map(normalizeEntry).filter(Boolean);
          saveEntries("watson", watson);
          saveEntries("eddie", eddie);
          setMsg("Imported successfully.");
          cancelEdit();
          render();
          return;
        }

        setMsg("Import failed — not a valid Doghouse backup.", true);
      } catch {
        setMsg("Import failed — invalid JSON file.", true);
      }
    };

    input.click();
  });

  els.clearDog.addEventListener("click", () => {
    const name = DOGS[activeDog];
    if (!confirm(`Clear all entries for ${name}?`)) return;
    saveEntries(activeDog, []);
    cancelEdit();
    setMsg(`Cleared ${name}.`);
    render();
  });

  // Init
  els.date.value = todayISO();
  setEntryType("weight");
  updateConverted();
  render();
</script>
</body>
</html>